스프링의 시작이다..!!


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Spring Dependency Injection >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 

< ------------------------------------------------------------Spring 소개와 학습 안내------------------------------------------------------------>
* Spring이 존재감을 보이게 된 이유
	1. dependency injection 기능	>> Enterprise Application 만들때 중요함
	2. transaction management 기능	>> 트랜잭션 관리를 깔끔하게 지원해준다. (단순하게 라이브러리만 쓰는방식으로 깔끔하게 처리 및 DI을 같이 쉽게 구현 -> 모듈결합 쉬워짐)

* Java EE버젼을 사용하지 않게됨
	기존 Java SE에 Java EE를 얹어서 사용했지만 이젠 Java SE + Spring으로 엮어서 사용가능하다

* 웹개발을 하겠다에 포커스를 맞추면 3가지 범주에 포커스가 맞춰짐
	
	1. MVC	---> 기존 MVC 모델방식으로 만들면 일일이 만들어야한다는 부담감 증가	---> Spring 라이브러리를 이용해 좀 더 편하게 만들기 가능
	>> Spring 제공하는 기능 ---> DI(Spring에서 MVC를 이용할때 이용됨) ---> 이걸 사용할 때 이애하기위해 느슨한 결합력과 인터페이스의 의미를 알아야함

	2. 트랜잭션	--->	DAO, Service계층을 나눠 프로그램을 만들경우 그들간 함수호출 관계에서 단일 트랜잭션 만들기 어려웠음 ----> 그것을 가능케하기위해 스프링에서 제공하는 트랜잭션 처리방법 공부함
	>> Spring ---> AOP(Spring에서 트랜잭션 처리시 이용됨)

	3. 인증과 권한	---> 웹사이트에서 사용자 인증과 권한
	>>>Spring ---> Spring서 인증과 권한 할 때 Servlet Filter 이용해 개발됨




< ------------------------------------------------------------느슨한 결합력과 인터페이스------------------------------------------------------------>
* 엔터프라이즈 어플리케이션을 만든다고 하면 기본적으로 사용하는 Layer
	UI 		---- 		Service 	  ---- 				DAO 									---- DB
	사용자의 비즈니스 ---- 사용자 요구에 맞는 서비스 담당 ---- 데이터 소스 접근 방법, 구현기술 숨기고 서비스 레이어에서 순수하게 자바를 이용해 데이터를 제공받을 수 있게해주는 DAO

* 서비스에서 기존 이용하던 DAO 객체(B1)가 새로운 객체(B2)로 수정되면 어떻게 수정해야 할까?
	단순 방법 : B1을 B2로 변경하고 Service에서 소스코드를 B1 -> B2로 변경 ---> 소스코드의 변경이 생기므로 결합력이 매우 높음
		소스코드 변경없이 변경하는 방법(결합력을 낮추는 방법)
	
	해결책1 : Service와 DAO를 결합시키는 작업은 UI에서 처리됨 어떻게? -> private B1 b = new B1(); ---> private B2 b = new B2()가 아닌 인터페이스를 이용해 private B b = new B2(); << (B is Interface type)
		 인터페이스를 이용하면 그 인터페이스를 구현하고 있는 객체들을 모두 참조 가능하다.

	해결책2 : 그러면 private B b = new B2()에서 new B2()는 어떻게 변경? ---> 소스코드를 수정 안하는 방식이 필요 ---> 기존 코드를 들어냄(DI)객체 생성과 조립을 위한 외부 설정 (XML, Annotation)혹은 외부파일을 이용함
		자바객체지향 33강 참조해보기

* 결론
	> 기업형 어플리케이션을 만들며 어떻게 유지보수 해야할까? ---> 소스코드변경은 위험부담 증가 따라서 대치하고 추가하는 방법이 필요
	 ---> 그러기 위해서는 설정 파일이 필요하다. ---> 인터페이스를 이용해 객체를 숨길 수 있다. ---> 결합을 낮추는 방법을 스프링이 도와줄 수 있다.










< ------------------------------------------------------------ DI(Dependency Injection) ------------------------------------------------------------>
* Spring 프레임워크의 가장 기본적인 능력
	1. 객체를 생성하고 조립해주는 능력(종속 객체를 생성 조립해주는 도구)
		여기서 사용되는 용어 [DI(Dependency Injection), IoC Container]
		DI : 부품 조립으로 이해하는 것이 편하다

* 부품 조립의 종류
	<Composition has a (일체형)>
	class A {
	  private B b;
	  public A() {
	    b = new B();
	  }
	}
	--> A가 B를 일체형으로 가졌다  --> 이때 B를 A의 부품이라고 말함(Dependency)

	<Association has a [조립형(세팅을해야만 사용가능)]>
	class A {
	  private B b;

	  public void setB(B b) {
	    this.b = b;
	  }
	}

* 스프링을 얘기할 때 DI가 왜 중요할까?
	> 프로그램을 만들 때 일체형 보다는 조립형이 결합력도 낮아지고 쉽게 갈아끼울 수 있기 때문에
	  업데이트 및 교체시 유용하여 기업형에서 선호하고 자주 사용된다.

	> B b = new B(); // 부품역할의 객체 다른말로 Dependency
	  A a = new A();

	  a.setB(b);	// 부품(Dependency)를 꽂는 작업 즉, 주입(Injection) 이라고 말함
	>> 조립형의 장점은 부품을 쉽게 바꿔 끼울 수 있다는 점 하지만, 부품을 조립해야하는 단점이 존재

* 조립하는 두 가지의 방법
	1. Setter Injection : Setter를 이용해 조립하는 방법(위의 코드)
	2. Construction Injection : 생성자를 이용해 조립하는 방법[B b = new B(); A a = new A(b);]

* 조립형은 자신이 원하는 부품을 선택해 성능을 올릴 수 있다. 하지만 조립하는데 불편함이 존재 --> 조립을 해주는 서비스가 필요
	1. DI(조립)을 해주는 역할 ---> Spring 즉 Dependency를 Injection 해주는 역할이다. ---> Spring을 이용하는 기본적인 이유

* DI는 결국 부품을 조립해준다. [종속성(Dependency) 주입]
* 이런 객체를 조립하는데 Container가 필요하다 이것이 IoC Container








< ------------------------------------------------------------ IoC(Inversion of Control) 컨테이너 ------------------------------------------------------------>
* Spring은 코어 능력은 부품을 조립해주는 능력이다. --> 이를위해 사용자들이 주문서를 넣으면 Spring은 주문서(XML, Annotation)대로 부품을 조립한다.(가장 기본은 XML파일)
* 주문서 입력대로 객체를 생성해서 담을 그릇 == Container이다. 하지만 부품 컨테이너(Dependency Container)가 아닌 IoC 컨테이너로 굳이 말함 왜? 다른 특별한 의미 존재

* 일체형(Composition)과 조립형(Association)의 부품 결합 순서는 다르다.
	> 일체형은 제일 상위 객체가 만들어지면 내부에 객체들이 순서대로 만들어진다.
	> 결합형은 부품이 생성되고 결합되는 순서는 제일 마지막 객체들이 만들어지고 결합된다. 따라서 역순의 순서를 가짐

* 이것이 Inversion of Control 즉 역순으로 무엇인가를 구성하는 컨테이너라는 의미 (IoC Container)
	> Dependency가 조립까지 된다 -> 조립에 대한 순서를 역순으로 객체를 생성하는 컨테이너(IoC Container)

* 부품이 역순으로 결합되고 담겨진다는 의미 강하게 내포










< ------------------------------------------------------------ Dependency를 직접 Injection 하기 ------------------------------------------------------------>
* Spring의 도움을 받아 부품을 생성하고 조립 해야함
	> 전에 부품조립을 Spring의 도움 없이 직접 해보기

public class Program {

	public static void main(String[] args) {
		// Exam = Interface
		// HoseokExam = Exam data 구현 객체
		Exam exam = new HoseokExam();
		
		// ExamConsole = Interface type
		// InlineExamConsole = Exam출력시 한줄에 출력
		//ExamConsole console = new InlineExamConsole(exam);
		
		// InlineExamConsole = Exam출력시 격자 형태로 출력
		ExamConsole console = new GridExamConsole(exam);	
		// InlineExamConsole, GridExamConsole들이 exam을 조립함 --> DI
		
		console.print();
	}
	
}

* 위의 코드에서 DI를 할때 소스코드 수정없이 가능할까? 
	> 가능케 하기 위해서 new GridExamConsole(exam);, new InlineExamConsole(exam); 이 부분이 코드로 존재하면 안됨
	> 그리고 외부설정으로 빼야함 --> 설정을 바꾸면서 DI를 바꿔치기 할 수 있다.
	> 객체를 생성하는 부분을 비워두고 누군가가 대신할 수 있도록 설정을 빼고 조립하는 작업 --> Spring이 대신 해줌











< ------------------------------------------------------------ 스프링 DI 설정을 위해 이클립스 플러그인 설치하기 ------------------------------------------------------------>
* 이전시간에는 자바코드로 DI를 직접 결합함 --> 변경시에 설정으로 빼야함 --> 직접 설정을 만들 수 있지만 잘 정리된 프레임워크가 이점이 있다.
* 이젠 Spring을 이용해서 DI를 구현해보자

* 어떤 모양으로 결합히기를 원하면 지시서가 필요하다(결합순서를 담은) --> Spring에게 SW가 이해할 수 있는 구문규칙을 이용해야함 --> XML, Annotation(XML을 이용할 것)

* XML을 사용해서 주문서 작성 시 마음대로 쓰는것이 아니다 --> 스프링이 제시하고 있는 지시서 양식을 따라 지시해야함
* 이클립스 플러그인을 설치해 작업함 --> 이클립스 Market place -> Spring

* 설치이후 new -> other -> Spring Bean Configuration File -> setting.xml 만들면(이름자유) 자동적으로 설정하는 파일(스프링이 제시하고 있는 지시서 양식)이 자동 생성됨

* 기본적인 준비과정 완료됨







< ------------------------------------------------------------ Spring DI 지시서 작성하기(Spring Bean Configuration) ------------------------------------------------------------>
* Spring을 이용한 DI적용하는 방법

public class Program {

	public static void main(String[] args) {
		Exam exam = new HoseokExam();						>>
		
		// InlineExamConsole, GridExamConsole들이 exam을 조립함 --> DI		>>
		//ExamConsole console = new InlineExamConsole(exam);			>>
		ExamConsole console = new GridExamConsole(exam);			>> HoseokExam을 GridExamConsole이 사용함 (HoseokExam이 DI 즉, 부품)
		
		console.setExam(exam); >> 일반적인 결합 형태
		console.print();
	}
}

* 결합 방식은 크게 두가지가 존재한다. setter, 또는 직접 대입
* 위 두가지 방법을 스프링을 통하면 어떻게 하게 될까?

* 두 개의 부품을 생성하고 -> Injection(결합,주입) 한 다음에 -> 콘솔을 이용해 출력
* 일련의 가정
	> Exam 객체가 변경되거나, Console객체가 변경되면 --> 바뀌는 것들을 설정으로 빼준다.
	> 결합관계도 변경되어야함 --> 결합관계도 설정으로 빼준다.

		빼줌 Exam exam = new HoseokExam();
		// InlineExamConsole, GridExamConsole들이 exam을 조립함 --> DI
		//ExamConsole console = new InlineExamConsole(exam);
		빼줌 ExamConsole console = new GridExamConsole();	
		
		빼줌 console.setExam(exam);

* ExamConsole객체가 필요한데 이것을 설정으로 빼서 누군가가 생성해줘야함 -> 어떻게? -> Spring
* 역할을 스프링이 해주고 코드에서는 설정하는 부분을 분리함
* 기존 빼줘야하는 부분들을 지시서로 변경함. (이전에 만든 setting.xml파일)
	> 지시서 이므로 자바코드가 아닌 데이터 기반으로 작성함

* XML파일에서 객체의 생성 및 결합을 표기하는 방법
	> 생성 : <bean>태그를 이용해 생성할 객체를 지정한다.
		ex) <bean id="exam" class="spring.di.entity.HoseokExam"></bean>  생성하려는객체=class, 
		변수명=id, class=생성할 객체명 다만 생성하려는 객체는 같은이름의 클래스를 가진 다른 객체가 있을 수 있으니 즉 동명이인이 존재할 수 있으므로
		다른 녀석이 생성되는 일이 발생하지 않도록 패키지명까지 같이 작성해야한다. 
		만약 같은 형식의 클래스가 존재하지 않으면 굳이 이름을 적지 않아도 된다. 

	> 결합 : console.setExam(exam);은 어떻게 결합해야 할까? (console이 exam을 갖음)
		아래와 같이 bean태그내에 <property> 태그를 이용해서 결합함 (setExam은 exam이란 속성을 세팅하는 것이므로 property이용)
		property내 속성에 값을 대입
			> name= 호출하려는 함수 --> 다만 setter존재시(setExam일경우) set생략, 대문자-> 소문자 변경(EL태그와 동일) name="exam" == setExam() 동일
			> value= 설정할 값의 이름 (값 형식일 경우 이곳에 작성)
			> ref = 설정할 참조형의 이름 (참조형식일 경우 이곳에 작성)
		다만 위와같은 형식을 이용하기 위해서는 console객체는 setter를 필수로 가지고 있어야한다. 또한 value, ref태그를 둘다 사용할 수 없다.
		위와 같은 과정이 Dependency Injection이 되겠다.

		> 결합코드
		<bean id="console" class="spring.di.ui.GridExamConsole">
			<property name="exam" value="" ref="exam"/>
		</bean>

	> 생성 및 결합 최종 코드 :
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
		
		<bean id="exam" class="spring.di.entity.HoseokExam"></bean>
		<bean id="console" class="spring.di.ui.GridExamConsole">
			<property name="exam" value="" ref="exam"/>
		</bean>
	</beans>











< ------------------------------------------------------------ Spring IoC 컨테이너 사용하기(ApplicationContext 이용하기)  ------------------------------------------------------------>
* 지시서를 읽어서 지시대로 객체를 만들고 만들어진 객체를 활용하는 방법
	> 주체를 생성할때 사용되는 구문 ApplicationContext context = new ClassPathXmlApplicationContext("config.xml");
	> ApplicationContext<Interface> : Spring에서 DI(지시서)를 읽어서 객체를 생성하고 조립하는 구체적 객체의 이름(인터페이스타입)
	> ClassPathXmlApplicationContext(XML_FILE) : 실제적으로 인터페이스를 구현하고 있음 --> 여러 종류의 ApplicationContext 존재

* ApplicationContext의 종류(지시서(XML)를 넘길때 지시서의 위치를 어떻게 넘겨주냐에따라 달라진다)
	> ClassPathXmlApplicationContext	: Application의 ROOT로 부터 경로를 지정(보편적으로 사용됨) --> src폴더가 루트
	> FileSystemXmlApplicaitonContext	: 특정 드라이브 어디에 있다 (현재 파일시스템의 경로를 이용해 루트로부터 써나갈때 사용)
	> XmlWebApplicationContext		: 웹에 지시서를 둠 (web의 url을 이용)
	> AnnotationConfigApplicationContext	: 파일이 아닌 Annotation으로 두었으므로 스캔하는 방법으로 사용된다.

* 실제 객체 생성해보기
	>  그 전에 기본 Java 프로젝트를 convert to Maven해주어 pom에 Spring라이브러리를 추가해줘야한다.
	> pom.xml에서 dependencies 검색으로 springframework검색 이후 org.springframework의 spring-context를 추가한다

	> 이후 ApplicationContext context = new ClassPathXmlApplicationContext("spring/di/setting.xml"); 을 추가하면
	  지시서대로 객체를 2개 생성하고 injection까지 완료해 보따리에 담음
	> 보따리 이름 : IoC Container, 여기서 지시서를 읽고 객체화하고 담은 그릇인데 이것의 구체적인 이름이 context가 된다.
	> IoC Contatiner를 사용할때 id값을 이용해서 꺼내쓰거나 class명(타입명)을 이용해 꺼내쓸 수 있다.


		>> 이름 : ExamConsole console = (ExamConsole) context.getBean("console");
			이름을 가지고 IoC Container에서 꺼내쓰기(Casting 작업이 필요하다)

		>> 타입 : ExamConsole console = context.getBean(ExamConsole.class);
			형식변환은 필요없다, 타입명을 문자열로 전달하는것이 아닌 ExamConsole이라는 녀석의 class타입에 맞는 녀석을 달라는 말
			즉 ExamConsole에 참조될 수 있는 객체를 찾아달라는 말(여기서는 인터페이스 형식이므로 인터페이스 형식에 참조될 수 있는것을 찾음)
			좀 더 구체화된 이름을 사용하면 더 구체화이름에 맞는 객체를 찾아옴
			만약 동일인터페이스로 두가지의 객체를 생성하게 되면 애매해지므로 구분할 수 있는 방법 요함

	> 이름보단 타입으로 불러오는 방식이 간편함

* 지시서 작성, 지시서대로 객체화해서 객체를 꺼내옴 (코드의 변경없이 외부설정에 대한 내용의 변화를 가지고도 프로그램을 변경할 수 있다.)
  즉 변화가 있다면 변화되는 부분을 설정(지시서)로 빼내어서 작성한다.








< ------------------------------------------------------------ 값 형식 DI  ------------------------------------------------------------>
* 지시할때 꼭 ref이 아닌 value를 이용해(<property>) 값을 세팅할 수 도있다. (값을 setter를 이용해 Injecttion하기)
	<bean id="exam" class="spring.di.entity.HoseokExam">
		<!-- 값 형식 DI 설정하기 -->
		<property name="kor" value="20"/>
		<property name="eng" value="50"/>
		<!-- 두 번째 방법 태그를 이용할 수 도있다.-->
		<property name="math">
			<value>80</value>
		</property>
		<property name="com">
			<value>50</value>
		</property>
	</bean>

* 위와같이 설정할 수 있다. 다만 getter, setter가 필수적으로 작성되어있어야 한다.
* 따라서 자바로 할 수 있었던 객체 생성, 초기화, 객체 조립 작업은 지시서에서도 할 수 있어야 한다.








< ------------------------------------------------------------ 생성자 DI  ------------------------------------------------------------>
* 생성자를 이용한 값을 설정하는 방법
	<constructor-arg> 태그를 이용한다.
	> 생성자를 생성하면서 값을 초기화 하는 경우에 사용될 수 있다.
	> 사용하기 이전에 개체 클래스에서 생성자를 추가한다
	<bean id="exam" class="spring.di.entity.HoseokExam">
		<!-- 생성자를 이용한 값 설정 fileds를 이용한 생성자에 순서대로 대입됨-->
		<constructor-arg value="10"/>
		<constructor-arg value="20"/>
		<constructor-arg value="30"/>
		<constructor-arg value="40"/>
	</bean>

	> 다만 위와 같은 문제는 순서가 헷갈릴 수 있으므로 착오를 일으킬 수 있다.
	> 따라서 순서를 지정하기 위해 아래와 같이 index 속성을 지정할 수 있다.
		<constructor-arg index="0" value="10"/>
		<constructor-arg index="1" value="20"/>
		<constructor-arg index="3" value="30"/>
		<constructor-arg index="2" value="40"/>

	> 이때 생성자의 형태는 아래와 같으므로 순서도래 10 20 40 30의 값이 kor, eng, math, com에 초기화된다.
	public HoseokExam(int kor, int eng, int math, int com) {
		this.kor = kor;
		this.eng = eng;
		this.math = math;
		this.com = com;
	}

* index말고도 명시적으로 name속성을 이용해 지정할 수 있다.
		<constructor-arg name="kor" value="10"/>
		<constructor-arg name="eng" value="20"/>
		<constructor-arg name="com" value="30"/>
		<constructor-arg name="math" value="40"/>

* 다만 동일한 순서의 생성자면서 자료형이 다른 생성자 호출의 모호한 매개변수가 존재하는 경우 위와같은 방법이 애매하다
	> 이 때 type도 지정할 수 있는 type옵션도 있다.
		<constructor-arg name="kor" type="float" value="10"/>
		<constructor-arg name="eng" type="float" value="20"/>
		<constructor-arg name="com" type="float" value="30"/>
		<constructor-arg name="math" type="float" value="40"/>

* 다만 생성자를 통해 값 호출시 태그가 너무 번잡하면 조금 더 쉽게 사용할 수 있는 옵션이 있다.
	> 설정 파일 처리기를 추가하여
	> 속성을 간단히 설정

	> xml파일 하단 namespaces를 선택한다 여기서 p라는 항목을 체크한다
	> xmlns:p="http://www.springframework.org/schema/p" 추가된다.
	> p라는 namespace가 추가되고 뒤에 주소는 namespace의 풀네임이 된다.

* namespace란?
	> 이름이라는 것을 식별하기 위해 앞에 붙여지는 성과같은 역할이다.
	> 성이 동일해도 이름을 식별하기위해 확장된 이름을 붙인다.

* 따라서 태그를 사용할때 두 개 이상의 처리기가 하나의 태그를 읽힐 수 있거나 혹은 원하는 처리기가 처리하길 원할때 접두사(namespace)를 사용한다.
	> <홍길동:bean></홍길동:bean>
	> <김길동:bean></김길동:bean>

* 접두사(namespace)를 이용한 태그의 구분이 갖는 두가지 의미
	1. 태그가 특정한 처리기에 의해 실행될 수 있도록 처리기가 처리할 태그를 특정짓기 위함
	2. 태그의 이름을 식별하기 위해 사용됨

* <bean id="exam" class="spring.di.entity.HoseokExam" p:kor="10" p:eng="20" p:math="30" p:com="40"/>
	> 위의 p가 누구에 의해 처리되는지 앞에다 밝혔으므로
	> bean이 가진 속성으로 인식되는것이 아닌 xmlns:p="http://www.springframework.org/schema/p" 처리기가 담당할 속성이라 말해줌

* 특별한 일이 아닌 이상 namespace : p 를 이용하기에 괜찮아 보인다.










< ------------------------------------------------------------ 콜렉션 생성과 DI ------------------------------------------------------------>
* XML을 이용해 콜렉션 생성 및 콜렉션에 객체 참조시키는 초기화 작업을 어떻게 DI 하는지 방법을 알아보자
* 변경하려는 코드
		List<Exam> exams = new ArrayList<>();
		exams.add(new HoseokExam(1,1,1,1));
		
		for (Exam e : exams) {
			System.out.println(e);
		}

* 먼저 bean 태그로 ArrayList생성
	<bean id="exams" class="java.util.ArrayList"/>

* 이후 클래스에서 getBean을 이용해 찾아옴
	List<Exam> exams = (List<Exam>) context.getBean("exams");//new ArrayList<>();

* 그렇다면 exams.add(newHoseokExam(1,1,1,1)); 은 어떻게 변경할까? (exams.add는 setter, getter가 아니므로 property태그를 이용해 세팅하는 방식으로 쓸 수 없음)
	> ArrayList를 생성할때 생성자에 컬렉션을 대입할 수 있는 능력이 있다. (new ArrayList(Collection C)를 이용)
	<bean id="exams" class="java.util.ArrayList">
		<!-- new ArrayList(Collection C)를 이용 -->
		<constructor-arg>
			<list>
				<bean class="spring.di.entity.HoseokExam" p:kor="10" p:eng="20" p:math="30" p:com="40"/>
				<ref bean="exam" />
			</list>
		</constructor-arg>
	</bean>

	> 생성자의 값을 설정하지만 내부에 설정되는 값이 컬렉션이므로 list태그를 이용해 초기화 하고자 하는 내용을 추가한다.
	> 우린 객체를 직접만들어 초기화 한다. 이곳에선 bean의 id값이 필요없다.
	> bean을 직접 만들지 않고 위에 존재하는 객체가 있으면 참조하여 사용할 수 있다. -> ref태그를 이용하여
	> 그렇게 되면 총 2개의 항목이 추가된다 1. 직접 만든 객체, 2.먼저 생성된 객체 참조

	> 이렇게 컬렉션 리스트를 생성자에 넘기는 방식으로 ArrayList를 만들게되면 항목을 추가하지 않아도 for each문에서 반복되어 출력된다.


* 위와 같은 방법은 정적인 방식으로 초기화하고 가져다 쓰는 방법이다.

* 그런데 생성자에다 목록으로 추가된 컬렉션을 가진 ArrayList를 만드는것이 아닌 위 자체가 ArrayList에 전달된 컬렉션이니 컬렉션을 개별적으로 따로 만드는 방법은 없을까?
	> 생성자에다가 목록을 추가하는 방식은 불편

* 그러려면 별도의 namespace가 필요하다 >> util
	기존 list태그는 목록을 세팅할 떄 사용되는 태그로 그 자체가 객체를 만드는 역할을 하진 못함
	util:list는 이름은 같지만 처리기가 다르고 실제로 객체를 만들 수 있도록 하는 능력을 가지고 있다.

* util:list 구현
	<util:list id="exams" list-class="java.util.ArrayList">
		<bean id="exam" class="spring.di.entity.HoseokExam" p:kor="1"
			p:eng="1" p:math="1" p:com="1" />
		<ref bean="exam" />
	</util:list>

	> 다양한 종류의 컬렉션이 존재하므로 어떤 리스트를 사용할지 구체화 해야함 : list-class 옵션
	> 직접 가져다 사용할 수 있으므로 id값 즉 이름을 가져다 사용할 수 있다. : id 옵션










< ------------------------------------------------------------ 어노테이션을 이용할 때의 장점과 @Authwired를 이용한 DI 해보기 ------------------------------------------------------------>
* 자바 어플리케이션 만들때 초기화 설정을 위한 두가지 방법
	1. XML을 이용해 외부파일로 설정 정보를 둠
	2. Annotation을 이용해 코드파일에 설정을 심음
	
	> DI하는 부분을 Annotation으로 바꿔보자

* Annotation을 사용하게 되는점의 장점

	* 예를 들어 아래와 같은 XML 코드가 있다. 뺀 이유는 결합상태를 바꾸기 위한 코드가 수정될수있으므로 소스코드 변경없이 내용을 변경하기위해서임.
		<bean id="b" class="data.B2" />
		<bean id="console" class="service.S">
			<property name="b" ref="b" />
		</bean>

		> 객체 B2를 신버전 B3로 변경하고 싶으면 class속성을 수정한다.
		> 하지만 이걸 수정하는것도 귀찮아짐 --> Annotation을 사용함(코드에 메타 데이터를 심음)

	* @Component 스프링이 코드를 읽게해 컴포넌트 어노테이션 발견시 객체화 하는 동작을한다

	* 만약 B3로 대체하게되면 도킹을 하게되는 annotation이 존재 -> @Autowired

	* 이렇게 되면 설정파일이 따로 존재하지 않음 --> 객체를 바꾸게되면 그 자체로 코드 및 설정도 같이 변경된다.

* 설정을 분리하는 방식(xml)에서 annotation을 이용해서 설정을 코드와 같이 가져가는 방식으로 변경

* 객체에 객체를 injection하는 부분을 annotation화 할것 --> <property name="exam" ref="exam"/> --> @Autowired
	> 제일먼저 xml에서 annotation으로 바꿀 부분이다.

* @Autowired의 역할
	> console에서 setter가있고 setter가 사용하는 속성 또는 setter에 @Autowired를 붙이면 xml에서 지울수있다.
	> 이렇게 되면 설정파일이 따로 존재하지 않음 --> 객체를 바꾸게되면 그 자체로 코드 및 설정도 같이 변경된다.


* @Autowired 사용하기
	1. annotation을 사용할 부분을 지워준다.
	<bean id="exam" class="spring.di.entity.HoseokExam" p:kor="10" p:eng="20" p:math="30" p:com="40"/>
	<bean id="console" class="spring.di.ui.GridExamConsole">
		<!-- <property name="exam" ref="exam"/> -->	--> 이부분을 지움
	</bean>


	2. GridExamConsole.setExam 메소드에 @Autowired 어노테이션을 작성
		> 하지만 객체를 만들어주는 부분에서 특별한 지시 없으면 클래스 내부에서 annotation이 있는지 찾지 않는다.

	3. 지시서에 부탁할 수 있는 키워드를 추가해야한다. 
		> context namespace를 추가하고 
		> <context:annotation-config/> 을 xml 최상단에 작성하면 객체들이 annotation을 가지고 있다는 의미로 한줄만 작성하면 객체를 만들면서 내부 설정에서 annotation을 찾음


* 기존 xml에선 <property name="exam" ref="exam"/> ref으로 어떤 객체를 세팅할지 명시해줬지만
  @Autowired는 태그를 지우고 annotation만 남기므로 따로 묶어줄 수 있는 근거가 부족하다.
	> 만약 xml내 동일한 형식의 객체가 2개가 있으면 어떤 객체를 바인딩 할것일까? --> 문제점 발생







< ------------------------------------------------------------ @Autowired와 @Qualifier ------------------------------------------------------------>
* @Autowired는 DI 하는 xml을 대신하는 annotation 설정임
	> 자동으로 무엇인가 해줄때 잘못된 방향의 DI가 될 수 있는 문제점이 존재하므로 이것과 관련된 annotation인 @Qualifier를 알아보자

* xml, annotation을 객체 생성 후 DI 할 떄 IoC Container를 가짐 --> 스프링이 가진 컨테이너는 객체를 생성하고 조립해주는 과정의 객체를 담음

* xml을 이용한 객체 생성과정을 annotation으로 변경하면 IoC Container에 xml방식과 동일하게 담긴다.

* Autowired 자동으로 찾아서 Exam을 세팅하는데 어떤걸 기준으로 찾을까? 자료형?, 변수명을 가지고 해당되는 이름?
	> 변수 이름(id값)을 변경할 경우 : 정상적으로 동작(심지어 없애도 동작), 또한 xml은 HoseokExam의 객체고 setExam의 매개변수는 인터페이스 타입 Exam이다 따라서
					  형식 명칭이 달라도 참조 가능한 객체를 자동으로 찾아준다
	> 객체가 컨테이너에 2개가 존재할경우 : No qualifying bean of type 'spring.di.entity.Exam' available: expected single matching bean but found 2 : 
					       사용할 객체는 1개인데 2개가 발견되어 모호하다는 오류가 발생
					     : 형식이 같은 객체가 두개 있을경우 이름으로 구분지어주면 바인딩이 된다. (이때는 이름이 동일해야한다.)
	> 이름이 다른 객체가 2개 존재할경우
		[xml]
		<bean id="exam1" class="spring.di.entity.HoseokExam" p:kor="10" p:eng="20" p:math="30" p:com="40"/>
		<bean id="exam2" class="spring.di.entity.HoseokExam" p:kor="20" p:eng="20" p:math="30" p:com="40"/>
		
		[code]
		@Autowired
		@Override
		public void setExam(Exam exam) {
			this.exam = exam;
		}

		> 이때는 코드에서 매개변수명을 변경하면 문제가 있음(코드의 변경 최소화)
		> 따라서 이때 @Qualifier("exam1") 이렇게 원하는 객체를 지정할 수 있다.

* @Qulifier("exam1")의 사용
		<bean id="exam1" class="spring.di.entity.HoseokExam" p:kor="10" p:eng="20" p:math="30" p:com="40"/>
		<bean id="exam2" class="spring.di.entity.HoseokExam" p:kor="20" p:eng="20" p:math="30" p:com="40"/>


		@Autowired
		@Qualifier("exam1")
		@Override
		public void setExam(Exam exam) {
			this.exam = exam;
		}


* 따라서 @Autowired가 어떤것을 기준으로 객체를 꺼내서 injection을 해주는지 잘 알고 있어야 함
	> 자료형식을 기본으로 함
	> 다만 식별이 모호할 경우 매개변수 이름도 같이 사용한다
		> 다만 xml에 부여한 id를 가지고 코드의 매개변수명을 변경하는건 문제가 있으므로 @Qualifier를 이용함









< ------------------------------------------------------------ @Autowired의 위치와 required 옵션  ------------------------------------------------------------>
* @Autowired는 설정할 수 있는 위치가 총 3곳이다. 그리고 required라는 옵션을 가지고 있다.
	1. setter
	2. constructor(오버로드 생성자)
	> 의존성을 주입할때(DI) setter를 사용하거나(property태그), 생성자(constructor-arg태그)를 사용하기 때문에 가능
	3. field위에
		> 2번은 오버로드 생성자에서 바인딩 3번은 overload생성자와 달리 기본생성자에서 객체를 바인딩하는 작업을 의미함

* 만약 기본생성자를 지우고 field위에 annotation을 두고 실행하면 오류발생 왜? 오버로드생성자가 있으면 기본생성자를 자동으로 생성해주지 않으므로
	> 따라서 기본생성자를 지우고싶다면 오버로드 생성자도 같이 지워주는게 바람직함

* 오버로드 생성자에 @Autowired와 @Qualifier를 두면 @Qualifier에서 오류가 발생함
	> 오버로드 생성자는 매개변수로 두 개 이상 올 수 있다고 생각되어 모호하다는 오류를 발생시킨다.
	> 따라서 각자 지정할 수 있게끔 매개변수에 직접 @Qualifier를 설정해야한다.

* 필드 인젝션은 사용하지 않도록 권고됨 --> 단위 테스트에서 문제가 발생 --> 따라서 생성자 인젝션이 바람직하다

* 만약에 객체가 애초에 생성되지 않고(xml파일에서 생성X) HoseokExam.exam==null 값을 가진다. 기존의 어노테이션방법은 바로 오류를 발생하고 종료됨
  하지만 아래와 같이 exam의 값이 null인경우 즉 생성된 객체가 없을 경우 기본값 0을 출력하고 싶다면 구현할 수 없게 된다.
	@Override
	public void print() {
		if (exam == null) {
			System.out.println("total :\t" + 0);
			System.out.println("avg :\t" + 0);
		}
		else {
			System.out.println("total :\t" + exam.total());
			System.out.println("avg :\t" + exam.avg());
		}
	}
  이럴때 @Autowired(required = false)로 required 옵션을 false로 두면 객체가 없어도 프로그램이 실행되고 print메소드에서 기본값을 출력한다.










< ------------------------------------------------------------ Annotation을 이용한 객체 생성  ------------------------------------------------------------>
* 객체를 생성하기 위한 annotation을 알아보자 아래의 xml을 annotation을 이용해 xml내용 빼보기
	1. <context:annotation-config/>
	2. <bean id="exam1" class="spring.di.entity.HoseokExam" p:kor="10" p:eng="20" p:math="30" p:com="40"/>	
	3. <bean id="console" class="spring.di.ui.GridExamConsole">

	4. </bean>

* 3, 4를 지우고 해당되는 GridExamConsole에서 최상단에 @Component를 작성하면되는데 지시서에 부탁할 수 있는 키워드도 추가해야한다.
	<context:component-scan base-package="spring.di.ui" />	: 패키지명 안에 클래스들을 스캔해서 컴포넌트가 있는지 찾고 컴포넌트가 있으면 그것을 객체화 시켜라 라는 명령(컴포넌트 지시)

* 이때 컴포넌트를 읽으면서 @Autowired도 읽게되므로 기존에 지시서에 부탁한 <context:annotation-config/> 명령어는 지워도 된다.

* 또한 console을 getBean으로 받아올때 이름으로 받아올 수 없게된다. --> bean태그를 지웠으므로 지정된 이름이 없다 따라서 형식으로 받아 오거나
  @Component에 이름을 붙일 수 있다. --> @Component("console")	--> xml에서 bean태그의 id속성 방식과 동일

* 이제 나머지 2의 부분도 @Component("exam1")로 설정한다 exam1로 이름을 명명한 이유는 GridExamConsole에서 @Qualifier("exam1")로 특정 객체를 이름을 이용해 DI하기 때문이다.
	> 여기서 @Autowired(required = false)가 생성된 객체가 없어도 일단 기본값으로 실행이 되게 하므로 지워준다.
	> 이후 실행하면 정상 작동









< ------------------------------------------------------------ 특화된 @Component 어노테이션 (@Controller/@Service/@Repository)  ------------------------------------------------------------>
* xml로 표현할때는 값을 초기화 하는방법을 Annotation으로 객체를 생성할때 어떻게 초기값을 설정하나?
	> @Value라는 Annotation을 이용해 설정

* 필드위에 @Value("20") 이렇게 설정하면 필드의 값이 20으로 초기화가 된다.

* 다만 Entity에 @Component를 붙이는 것은 컴포넌트 어노테이션과 개념상 잘 맞지 않음

* @Component는 MVC 방식으로 웹 어플리케이션을 만들경우 MVC를 구성하고 있는 자바코드(업무형로직코드)를 가진 코드를 @Component라 함 
	> 따라서 @Component보단 좀 더 의미 있는 이름을 가진 어노테이션을 사용한다
	> @Component에는 @Controller, @Service, @Repository가 있다.
	> 하는 동작은 같으나 @Component보다 조금 더 역할로서의 의미가 부여되고 있는 @Component Annotation임
	> 차이점은 이름이 조금 더 특화되었다는 점

* @Controller, @Service, @Repository를 달고있어야할 클래스는 어떤것일까?
	> @Controller : 사용자 입출력을 담당하는 Controller
	> @Service : 사용자 요청을 받으면 요청에 맞게 데이터 서비스를 위임받음(사용자의 요구사항에 맞는 서비스제공 업무단위, 트랜잭션 단위)
	> @Repository : 서비스에 데이터를 제공해주는 DAO 클래스

* 여기서 HoseokExam은 Entity로써  Service와 DAO사이에서 전달되지만 일반적으로 @Component로 붙여서 사용하지 않음(Model도 마찬가지)

* 또한 우리가 사용하는 클래스는 자바플랫폼 또는 남이 만든 클래스를 사용할 경우가 있음 --> 소스코드를 가지고 있지 않다.
	> @Component라는 어노테이션 붙여서 사용하는것이 불가능함
	> 그렇다면 bean태그 사용을 위해 스프링을 xml로 구현하여 xml, annotation을 겸해서 둘 다 사용해야 할 까?

* 모든것들을 xml에서 제외하고 어노테이션으로 구현할 수 있고 config자체를 자바로 바꾸는 방법이 있다.
	> 모든 생성 코드는 어노테이션을 이용함 -> 따라서 XML 지울 수 있다.
	> 따라서 Exam Entity의 @Component 어노테이션을 지우고 다른 방법을 알아보자.










< ------------------------------------------------------------ XML Configuration을 Java Configuration으로 변경하기  ------------------------------------------------------------>
* 지금까지는 Config 설정을 xml로 진행함(Dependency 생성, 및 의존성 Injection)
* 현재 xml을 지우고 대신할 수 있는 설정 파일로 자바 클래스를 둔다
* 클래스가 일반적인 자바클래스가 아니라 설정을 위한 자바클래스 이므로 @Configuration 어노테이션을 추가함
* 또한 @ComponentScan("spring.di.ui")도 어노테이션을 이용해 추가
* 두 개 이상의 패키지를 스캔범위에 두려면 @ComponentScan({"spring.di.ui", "spring.di.entity"}) 배열형태로 추가한다

* xml에서 bean 태그를 이용해 객체를 만들었다면 똑같은 방식으로 이를 자바 구성 클래스에선 어떻게 만들까?
	> 객체를 직접 생성하는 작업 이후 어노테이션을 붙임 
	@Bean
	public Exam exam() {
		return new HoseokExam();
	}

	> xml은 객체 생성시 스프링에게 부탁하고 스프링이 직접 의존성을 생성했다. 하지만 위 방식은 내가 직접 만들게됨 --> 지시서 느낌이 안듦
	> @Bean 어노테이션의 역할은 프로그램에서 사용가능한 공유 가능 객체들을 모아놓은 IoC Container에 담기위해 붙여준다.
	> xml에서 이름을 가지고 컨테이너에 담고 이름을 통해 객체를 꺼내옴
		> 하지만 자바 config에선 함수명이 명사형이다. 이는 bean태그의 id값이 함수의 이름이 된다.
		> 따라서 @Bean이 있으면 함수명이 아니라 컨테이너에 담겨졌을때 id값(이름)으로 부여되는것이라 생각해야함
		> 즉 객체가 컨테이너에서 이름을 사용해서 가지고 담겨있다.

* 클래스명은 끝에 Config를 붙여 구분해준다.
* 여기서 생성되는 메소드는 Spring이 호출한다.
	> @Bean이라는 어노테이션을 설정하면 Spring이 메소드를 호출해서 메소드가 만들어낸 객체를 IoC Container에 담게된다.
	> 이렇게 생성하게 되면 기존 xml 설정과 일치하게 된다.

* xml을 사용할지 자바 config를 사용할지는 선택할 수 있다.
	> ApplicationContext를 통해 선택할 수 있다.
	> AnnotationConfigApplicationContext(HoseokDIConfig.class); 호출함

* 클래스 설정 방법, 1개의 설정 파일 뿐만아니라 여러개의 config 파일을 설정할 수 있다. 즉 config 설정을 나눠서 설정가능
	* 설정방법 1
	public class Program {
		public static void main(String[] args) {

			ApplicationContext context = new AnnotationConfigApplicationContext(HoseokDIConfig.class);
			
			// 이름을 가지고 IoC Container에서 꺼내쓰기(Casting 작업이 필요하다)
			ExamConsole console = (ExamConsole) context.getBean("console");
			console.print();
		}
	}

	* 설정방법 2
	public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		//ctx.register(AppConfig.class, OtherConfig.class);	// 괄호안에서 여러개 한번에 하고싶으면 쉼표로 구분 혹은 나눠서 여러번 호출해도 가능
		ctx.register(HoseokAppConfig.class);
		ctx.refresh();	// 설정된 내용을 다시 읽어들이며 IoC Container에 담겨진 객체들을 활용할 수 있게 된다.

		ExamConsole console = (ExamConsole) ctx.getBean("console");
		console.print();
	}

* DI를 넘어서서 AOP를 배워보자!!















<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Spring AOP(Aspect Oriented Programming) >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>






< ------------------------------------------------------------ AOP(Aspect Oriented Programming) 이란?  ------------------------------------------------------------>
* AOP란 Spring이 아니라 하나의 방법론
	> AOP를 구현할 때 Spring이 도움을 줌 : Spring이 지원하는 범주내에서 AOP 방법론으로 프로그램을 짜면 어떤 도움을 받을까?

* AOP 이해하기
	> 우리는 지금까지 Object Oriented Programming에 관심이 있었음 : 사용자가 원하는 업무 기반의 로직만 관심을 가짐
		> 사용자의 업무를 분석을 하고 그것에 대한 로직을 구현함
	> 다만 우리가 체감하지 못한 코드가 주 업무 로직에 들어가 있었음
		> 사용자 요구를 수반하기 위한 코드가 들어가있음 (개발자 또는 관리자가 프로그램을 구현하기 위해서 혹은 테스트 하기 위한 코드들이 존재)
		> 이러한 코드들은 주 업무 로직이 아니며 사용자는 모르는 내용(개발자가 개발자를 위해서 끼워넣은 부가적인 코드)

	> 이러한 개발자 혹은 운영자를 위해 넣는 코드들도 관점이 다른 하나의 업무라고 볼 수 있다.
	> 따라서 관점에 따라 프로그램을 나누어서 만들게 된다.
	
	> Object Oriented Programming은 사용자 관점으로 만듦(주업무로직)
	> 이것 외에 개발자, 운영자를 위한 관점에 대한 내용도 프로그램에 넣어야함

	> 관점 지향 프로그래밍은 어떻게 보면 객체지향프로그래밍보다 큰 단위가 됨(객체지향은 사용자를 위한 주 업무 로직에 포함됨)


* Primary(Core) Concern과 Cross-cutting Concern
	> 주 관심사(Primary(Core) Concern)에 해당되는 것들은 객체로 만들어지고 실질적인 업무는 메소드가 됨
	> 객체가 객체를 이용하면 화살표로 표시
	
* 객체 지향 프로그래밍으로 사용자 업무를 만들었다 하지만 필요에 따라 사용자가 모르고 아래와 같이 개발자에게 필요한 것들이 필요
	> 로그처리
	> 보안처리
	> 트랜잭션 처리
	> 위와 같은 로직들은 주 업무 로직(사용자의 요구)가 아닌 사용자의 요구를 수반하려면 필요한 로직 즉 개발자에게 필요함
	> 주로 주 업무 로직 앞과 뒤쪽에 껴들어가게 되어있다. (빵또아 아이스크림 같이)
	> 이것을 가로로 잘라서 떼어낸다면 Cross-cutting Concern(관점이 다른 로직)이라 불림
	> 이는 뺐다 꼈다 자유로워야 한다. > 과거에는 이런 커팅 작업이 쉽지 않았다. > 소스코드를 직접 열어서 주석을 하거나 다시 주석을 풂 > 실제코드에 손을댐
	> 쉽게 빼고 끼기 위한 방법론 ---> AOP

* AOP는 관점에 해당되는 코드를 직접 꽂아넣지 않고 마치 꽂아넣은것처럼 실행될 수 있게하는 방법론
	> 프로그램은 흐름이므로 주업무로직은 일단 만듦
	> 만약 로그를 추가하고 싶다면 먼저 Cross-Cutting Concern을 따로두어 초기에 이것이 먼저 실행되게하고 다음으로 Core Concern을 실행하고 마무리로 Cross-Cutting Concern을 실행함
	> 이렇게되면 직접 껴있지 않지만 실행흐름은 코드가 같이 있는것처럼 실행된다.
	> 즉 곁다리 업무를 따로 분리하고 곁다리 업무에 주 업무를 호출하게 하거나 직접 Core Concern을 사용하게 하거나 
	  Cross-Cutting Concern이 Core concern을 실행하게해 관점이 다른 로직을 쉽게 뺏다 꼈다 할 수 있게 한다.
	> 이 때 Spring을 이용하면 뺏다 꽂았다 하는 과정이 매우 자연스럽고 쉽게 구현이 가능하다.

* AOP는 Spring으로도 구현이 가능하지만 Java만 가지고도 구현이 가능하다.








< ------------------------------------------------------------ AOP 자바코드(구현방식) 이해하기   ------------------------------------------------------------>
* AOP구현방식에 대해 이해하자

public class HoseokExam implements Exam {
	
	@Override
	public int total() {
	}

	@Override
	public float avg() {
	}



* 위의 클래스에선 total() avg() 메소드를 구현하고 있었음 > 이는 사용자가 요구하는 요구사항 및 사용자에게 서비스 해야할 로직을 구현함

* 때로는 새로운 관점이 생김
	> 권한을 주기 위한 코드를 삽입하거나
	> 실행시간을 알아보기 위한 시간타임을 출력하는 로그 추가

* 업무로직과 별개에 관점에 따라서 코드를 넣고 싶음
	> 과거에는 주 업무 로직과 상관없는 다른 관점의 코드를 주업무로직에 같이 작성함
	public class HoseokExam implements Exam {
		/* 이곳에 다른관점 작성 */
		@Override
		public int total() {
		}

		@Override
		public float avg() {
		}

		/* 이곳에 다른관점 작성 */
	}

* 만약 주 업무 로직에 대한 코드를 가지고 있지 않으면 코드를 삽입하는 행위 자체가 불가능해짐 --> 문제 발생 --> 이것을 가능케하는 방법론?
	> AOP

* AOP를 구현하는 방법
	> 주 업무 로직에서 다른 관점의 코드를 분리함
	> 이런 코드를 Cross-cutting Concern이라 불리고 주 업무 로직은 Core Concern이라 불림
	> 그리고 Cross-cutting Concern을 꽂아넣을 방법을 찾아야함
	> Core Concern소스코드가 있든 없든 꽂아넣을 방법을 찾아야함
	> 흐름상으로 봤을때 같이 있는것과 같이 실행절차를 만든다. --> proxy라는 개념

* 프록시 클래스에 구현되는 Cross-cutting Concern
	> 사용자가 프록시를 호출하면 프록시에서 주업무를 호출하는 곳에서 전, 후로 Cross-cutting Concern에 해당되는 코드를 작성할 수 있다.
	> 따라서 실행순서가 Cross-cutting Concern -> Core Concern -> Cross-cutting Concern 순서로 실행 된다. (마치 주 업무로직에 코드를 꽂은것과 동일한 실행순서를 가진다.)
	> 이렇게 하면 소스코드 없이 남이 만든 코드 또는 전에 만든 코드에 앞 뒤에 Cross-cutting Concern을 실행시킬 수 있다.
	> 프록시의 방법은 Spring과 아무상관 없음, 순수한 Java 코드로 구현하는 방식이다.
	> 프록시의 결합과 분리를 Spring의 DI를 이용하면 쉽게 이용가능함






< ------------------------------------------------------------ 순수 자바로 AOP 구현해보기   ------------------------------------------------------------>
* AOP 구현 전에 업무로직을 가지고 있는 하나의 클래스가 있어야 함 --> 그곳에 곁다리 업무(Cross-cutting Concern)을 꽂아 넣음

* 기존의 total(), avg() 메소드를 result에 계산 값을 담아 result를 리턴해 곁다리 업무를 추가할 수 있는 구조로 변경

	@Override
	public int total() {
		
		int result = kor + eng + math + com;
		
		return result;
	}
* 기존의 total() 메소드가 성능이 안좋다는 피드백 받음 --> total() 메소드에 시작과 끝 부분에 시간을 체크하기 위한 코드 추가 --> 프로그래머, 운영자 관점(Cross-cuttgin Concern)
	> 따라서 기존의 업무 로직 코드에 시간 출력 코드(Cross-cutting Concern) 작성
	@Override
	public int total() {
		// Cross-cutting Concern
		long start = System.currentTimeMillis();
		/*---------------------------------*/
		
		// Core Concern
		int result = kor + eng + math + com;
		
		
		
		/*---------------------------------*/
		// Cross-cutting Concern
		try {
			Thread.sleep(200);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		long end = System.currentTimeMillis();
		
		String message = (end - start) + "ms 시간이 걸렸습니다.";
		System.out.println(message);
		
		return result;
	}

* AOP 방식으로 변경 (소스코드에 직접작성하지 않고 분리하고 연결하겠다)
	> Cross-cutting Concern을 따로 만들고 그것을 연결해 줄 수 있는 proxy 도구를 이용한다.
	> Java는 Proxy 도구를 지원해줌
	> Proxy.newProxyInstance(loader, interfaces, h); 는 인스턴스를 만들어줌 --> Interface타입 따라서 Exam 객체를 생성가능 --> 가짜 Exam(Proxy는 가짜라는 뜻도 가짐)
	> proxy가 가진 기능이 기존 exam과 똑같은 기능을 가지지만 곁다리업무(Cross-cutting Concern)를 가지는것의 차이가 있다.

	> loader : 프록시는 가짜지만 실제 업무를 호출해야 하므로 업무를 실행할 객체의 정보를 넣어줘야함 HoseokExam.class.getClassLoader()
	> interfaces : 인터페이스 정보를 넘겨준다, 복수형 이므로 배열을 전달 new Class[] {Exam.class} : 여러개의 인터페이스를 구현하고 있으면 여러 인터페이스를 전달한다.
	> h : 곁다리 업무를 꽂을 수 있는 부분이다. : InvocationHandler라는 인터페이스를 구현한 클래스를 객체화 해야함, 별도의 클래스파일 생성없이 익명으로 익명 클래스를 작성
		> 위 아래는 곁다리 업무, 가운데는 실제 업무 코드를 작성함

* new InvocationHandler() 구현
	public Object invoke(Object proxy, Method method, Object[] args) 메소드 존재

	> Cross-cutting Concern 사이에 실제 업무 로직을 작성해야함 이를 위해 실제 업무를 담당하는 메소드를 호출하는 기능인 method를 이용한다.
	> method.invoke(obj, args) : obj는 실제 업무 객체 exam을 넣어주고 Object[] args는 우리가 total()혹은 avg() 메소드를 호출할 수 있게 되는데 호출하는 메소드가 가진 파라미터를 넘겨주며
	  인자를 빠트리지 않도록 한다. 또한 invoke호출 시 업무로직에서 반환하는 값을 다시 반환하기 위해 Object result에 담는다.

* proxy.total()을 실행하면 화면에 경과된 시간이 찍힌다 --> Cross-cutting Concern -> Core Concern -> Cross-cutting Concern 순으로 실행
  exam.tatal()을 실행하면 업무 로직만 실행된다.
	> 따라서 원할때 곁다리 업무를 넣고 뺄 수 있게된다.
	> 또한 인터페이스를 공유하는 다른함수를 사용해도 로그(곁다리 업무)를 끼울 수 있다.	






< ------------------------------------------------------------ 스프링으로 AOP 구현해보기-AroundAdvice   ------------------------------------------------------------>
* 업무 로직과 의미가 다른 코드를 뺐다 꽂았다 하기 위해 분리하기 위한 방법 이용 : AOP
	> 관점이 다른 코드를 업무로직과 연관해 코드를 쉽게 붙이고 쉽게 작성하고 쉽게 유지보수할 수 있는지에 대한 방법론
	> 기존에 proxy를 이용해 곁다리 업무를 꽂고 실제 업무로직에는 아무런 코드를 작서하지 않음

* 위와 같은 구성을 Spring으로 이용하면 좀 더 편해질까?
	> AOP를 구현할 때 Spring을 이용하던 하지 않던 Proxy가 있어야 하고 Proxy 꽂을 Cross-cutting Concern과 업무로직이 있어야한다.
	> 위 3개가 도킹이 됐다 안됐다 자유로워야함 -> Spring이 좀 더 쉽게 할 수 있게 도와준다.

* Spring은 직접 제공하고 있는 Proxy 클래스를 이용해 IoC Contatiner에 담고 수행하게될 2개의 업무(주업무, 곁다리업무)를 따로 만들어서 꽂아 넣을 수 있게함 (IoC Container의 큰 장점)
	> 3가지의 객체를 꽂았다 뺐다 할 수 있음

* 만약 작성하는 곁다리 업무 코드가 앞에만 작성하는 경우도 있음 혹은 뒤에만 넣어야 하는 경우도 있다.
	> 주 업무 실행 전 무엇인가를 검사해야하는 경우 등등

* 따라서 Spring에서는 위와 같은 형태를 총 4가지로 구분하고 있다.
	> Before : 앞에만 필요한 Cross-cutting Concern(곁다리 업무)
	> After returnning : 뒤에만 필요한 Cross-cutting Concern(곁다리 업무)
	> After throwing : 예외를 처리하는 Cross-cutting Concern(곁다리 업무)
	> Around : 앞 뒤 모두 필요한 Cross-cutting Concern(곁다리 업무)

	> 4가지로 구분하고 이들을 각각 Before Advice, After returninng Advice, After throwing Advice, Around Advice라 말함

* 4가지 중 내가 구현하고자 하는 형태에서 가장 알맞은 것을 인터페이스를 상속받아 구현하여 꽂아 넣는다.
	> 실행시간 로그를 찍을때 사용된 건 Around Advice와 가장 근접함

* xml파일로 AOP 설정하기
	> xml 파일에 3가지를 설정해야함
	> HoseokExam() 생성, Proxy.newProxyInstance() 생성, 곁다리 업무를 작성해서 꽂아넣을 코드

* HoseokExam(), 곁다리 클래스 생성
	<!-- Exam exam = new HoseokExam(1, 1, 1, 1); -->
	<bean id="target" class="spring.aop.entity.HoseokExam" p:kor="1" p:eng="1" p:math="1" p:com="1"/>
	<!-- 로그를 출력하기 위한 클래스 -->
	<bean id="logAroundAdvice" class="spring.aop.advice.LogAroundAdvice"/>

* Proxy 생성
	> proxy 생성은 실제 HoseokExam 객체(target)에 해당되는 ClassLoader를 넣고, 곁다리 업무에 해당되는 로직을 설정해야하 한다. (인터페이스형식은 Spring이 알아서 해줌)
	> 따라서 target과 Handler(Cross-cutting Concern)만 넣어주면 동작이 된다.
	> target은 name="target", Handler는 name="intercpetorNames" 옵션을 이용 Handler는 복수형이므로 list 태그를 이용해 여러개를 넣어줄 수 있다.
	> list 태그는 참조열이므로 내부에 쓰이는 value태그는 값이 아닌 참조하고 있는 녀석의 이름을 넣어준다.
	<!-- proxy 객체 만들기 -->
	<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">
		<!-- HoseokExam 객체 설정하기 -->
		<property name="target" ref="target"/>
		<!-- 복수형, 여러개 넣기 가능 -->
		<property name="interceptorNames">
			<list>
				<!-- value라고 말했지만 list태그는 참조열 이므로 value는 참조하고 있는 녀석의 이름을 넣어준다. -->
				<value>logAroundAdvice</value>
			</list>
		</property>
	</bean>

	> 또한 로그출력 곁다리 코드를 만들기 위해 클래스를 만들어야한다. 이는 MethodInterceptor라는 인터페이스를 상속받는다.
	> 여기서 오버라이드 되는 public Object invoke(MethodInvocation invocation) 메소드는 이전에 순수 자바로 구현한 AOP의 invoke함수와 동일한 역할을 한다.
	> 여기서 invocation.proceed();는 자바 AOP에서 method.invoke()와 동일한 역할을 한다.
	> 이것 외에는 앞뒤에 들어갈 내용이 동일하다.
	> 또한 proceed() 메소드는 target을 쓰기 위해 exam, args의 인자들을 넘겨받지 않아 다른 외부적인 요소와 연관되지 않게끔 해결함.
	public class LogAroundAdvice implements MethodInterceptor{

		@Override
		public Object invoke(MethodInvocation invocation) throws Throwable {
			// Cross-cutting Concern
			long start = System.currentTimeMillis();

			// Core Concern 실제 업무 로직 호출
			Object result = invocation.proceed();
		
			// Cross-cutting Concern
			long end = System.currentTimeMillis();

			String message = (end - start) + "ms 시간이 걸렸습니다.";
			System.out.println(message);

			return result;
		}
	}

* xml 최종
	<!-- Exam exam = new HoseokExam(1, 1, 1, 1); -->
	<bean id="target" class="spring.aop.entity.HoseokExam" p:kor="1" p:eng="1" p:math="1" p:com="1"/>
	<!-- 로그를 출력하기 위한 클래스 -->
	<bean id="logAroundAdvice" class="spring.aop.advice.LogAroundAdvice"/>
	
	<!-- proxy 객체 만들기 -->
	<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">
		<!-- HoseokExam 객체 설정하기 -->
		<property name="target" ref="target"/>
		<!-- 복수형, 여러개 넣기 가능 -->
		<property name="interceptorNames">
			<list>
				<!-- value라고 말했지만 list태그는 참조열 이므로 value는 참조하고 있는 녀석의 이름을 넣어준다. -->
				<value>logAroundAdvice</value>
			</list>
		</property>
	</bean>

* 따라서 main의 기존 자바로 구현한 proxy생성 및 Cross-cutting Concern부분은 주석처리한다.
* 최종 Program.java 코드
public class Program {

	public static void main(String[] args) {

		// xml configuration
		ApplicationContext context = new
				ClassPathXmlApplicationContext("spring/aop/setting.xml");

		// xml에서 id="proxy"해당되는 객체를 가져옴
		Exam exam = (Exam) context.getBean("exam");
		// annotation configuration
		//ApplicationContext context = 
		//		new AnnotationConfigApplicationContext(HoseokDIConfig.class);

		System.out.printf("total is %d\n", exam.total());
		System.out.printf("total is %f\n", exam.avg());

	}
}
* 여기서 xml에서 proxy객체 생성 및 DI부분을 지우고 기존의 HoseokExam의 id 값을 exam으로 변경하여 실행하면 실제 소스코드의 변경없이 설정의 변경만으로도
  Cross-cutting Concern을 끼고 뺄 수 있다.


























































































