스프링의 시작이다..!!


< ------------------------------------------------------------Spring 소개와 학습 안내------------------------------------------------------------>
* Spring이 존재감을 보이게 된 이유
	1. dependency injection 기능	>> Enterprise Application 만들때 중요함
	2. transaction management 기능	>> 트랜잭션 관리를 깔끔하게 지원해준다. (단순하게 라이브러리만 쓰는방식으로 깔끔하게 처리 및 DI을 같이 쉽게 구현 -> 모듈결합 쉬워짐)

* Java EE버젼을 사용하지 않게됨
	기존 Java SE에 Java EE를 얹어서 사용했지만 이젠 Java SE + Spring으로 엮어서 사용가능하다

* 웹개발을 하겠다에 포커스를 맞추면 3가지 범주에 포커스가 맞춰짐
	
	1. MVC	---> 기존 MVC 모델방식으로 만들면 일일이 만들어야한다는 부담감 증가	---> Spring 라이브러리를 이용해 좀 더 편하게 만들기 가능
	>> Spring 제공하는 기능 ---> DI(Spring에서 MVC를 이용할때 이용됨) ---> 이걸 사용할 때 이애하기위해 느슨한 결합력과 인터페이스의 의미를 알아야함

	2. 트랜잭션	--->	DAO, Service계층을 나눠 프로그램을 만들경우 그들간 함수호출 관계에서 단일 트랜잭션 만들기 어려웠음 ----> 그것을 가능케하기위해 스프링에서 제공하는 트랜잭션 처리방법 공부함
	>> Spring ---> AOP(Spring에서 트랜잭션 처리시 이용됨)

	3. 인증과 권한	---> 웹사이트에서 사용자 인증과 권한
	>>>Spring ---> Spring서 인증과 권한 할 때 Servlet Filter 이용해 개발됨




< ------------------------------------------------------------느슨한 결합력과 인터페이스------------------------------------------------------------>
* 엔터프라이즈 어플리케이션을 만든다고 하면 기본적으로 사용하는 Layer
	UI 		---- 		Service 	  ---- 				DAO 									---- DB
	사용자의 비즈니스 ---- 사용자 요구에 맞는 서비스 담당 ---- 데이터 소스 접근 방법, 구현기술 숨기고 서비스 레이어에서 순수하게 자바를 이용해 데이터를 제공받을 수 있게해주는 DAO

* 서비스에서 기존 이용하던 DAO 객체(B1)가 새로운 객체(B2)로 수정되면 어떻게 수정해야 할까?
	단순 방법 : B1을 B2로 변경하고 Service에서 소스코드를 B1 -> B2로 변경 ---> 소스코드의 변경이 생기므로 결합력이 매우 높음
		소스코드 변경없이 변경하는 방법(결합력을 낮추는 방법)
	
	해결책1 : Service와 DAO를 결합시키는 작업은 UI에서 처리됨 어떻게? -> private B1 b = new B1(); ---> private B2 b = new B2()가 아닌 인터페이스를 이용해 private B b = new B2(); << (B is Interface type)
		 인터페이스를 이용하면 그 인터페이스를 구현하고 있는 객체들을 모두 참조 가능하다.

	해결책2 : 그러면 private B b = new B2()에서 new B2()는 어떻게 변경? ---> 소스코드를 수정 안하는 방식이 필요 ---> 기존 코드를 들어냄(DI)객체 생성과 조립을 위한 외부 설정 (XML, Annotation)혹은 외부파일을 이용함
		자바객체지향 33강 참조해보기

* 결론
	> 기업형 어플리케이션을 만들며 어떻게 유지보수 해야할까? ---> 소스코드변경은 위험부담 증가 따라서 대치하고 추가하는 방법이 필요
	 ---> 그러기 위해서는 설정 파일이 필요하다. ---> 인터페이스를 이용해 객체를 숨길 수 있다. ---> 결합을 낮추는 방법을 스프링이 도와줄 수 있다.










< ------------------------------------------------------------ DI(Dependency Injection) ------------------------------------------------------------>
* Spring 프레임워크의 가장 기본적인 능력
	1. 객체를 생성하고 조립해주는 능력(종속 객체를 생성 조립해주는 도구)
		여기서 사용되는 용어 [DI(Dependency Injection), IoC Container]
		DI : 부품 조립으로 이해하는 것이 편하다

* 부품 조립의 종류
	<Composition has a (일체형)>
	class A {
	  private B b;
	  public A() {
	    b = new B();
	  }
	}
	--> A가 B를 일체형으로 가졌다  --> 이때 B를 A의 부품이라고 말함(Dependency)

	<Association has a [조립형(세팅을해야만 사용가능)]>
	class A {
	  private B b;

	  public void setB(B b) {
	    this.b = b;
	  }
	}

* 스프링을 얘기할 때 DI가 왜 중요할까?
	> 프로그램을 만들 때 일체형 보다는 조립형이 결합력도 낮아지고 쉽게 갈아끼울 수 있기 때문에
	  업데이트 및 교체시 유용하여 기업형에서 선호하고 자주 사용된다.

	> B b = new B(); // 부품역할의 객체 다른말로 Dependency
	  A a = new A();

	  a.setB(b);	// 부품(Dependency)를 꽂는 작업 즉, 주입(Injection) 이라고 말함
	>> 조립형의 장점은 부품을 쉽게 바꿔 끼울 수 있다는 점 하지만, 부품을 조립해야하는 단점이 존재

* 조립하는 두 가지의 방법
	1. Setter Injection : Setter를 이용해 조립하는 방법(위의 코드)
	2. Construction Injection : 생성자를 이용해 조립하는 방법[B b = new B(); A a = new A(b);]

* 조립형은 자신이 원하는 부품을 선택해 성능을 올릴 수 있다. 하지만 조립하는데 불편함이 존재 --> 조립을 해주는 서비스가 필요
	1. DI(조립)을 해주는 역할 ---> Spring 즉 Dependency를 Injection 해주는 역할이다. ---> Spring을 이용하는 기본적인 이유

* DI는 결국 부품을 조립해준다. [종속성(Dependency) 주입]
* 이런 객체를 조립하는데 Container가 필요하다 이것이 IoC Container








< ------------------------------------------------------------ IoC(Inversion of Control) 컨테이너 ------------------------------------------------------------>
* Spring은 코어 능력은 부품을 조립해주는 능력이다. --> 이를위해 사용자들이 주문서를 넣으면 Spring은 주문서(XML, Annotation)대로 부품을 조립한다.(가장 기본은 XML파일)
* 주문서 입력대로 객체를 생성해서 담을 그릇 == Container이다. 하지만 부품 컨테이너(Dependency Container)가 아닌 IoC 컨테이너로 굳이 말함 왜? 다른 특별한 의미 존재

* 일체형(Composition)과 조립형(Association)의 부품 결합 순서는 다르다.
	> 일체형은 제일 상위 객체가 만들어지면 내부에 객체들이 순서대로 만들어진다.
	> 결합형은 부품이 생성되고 결합되는 순서는 제일 마지막 객체들이 만들어지고 결합된다. 따라서 역순의 순서를 가짐

* 이것이 Inversion of Control 즉 역순으로 무엇인가를 구성하는 컨테이너라는 의미 (IoC Container)
	> Dependency가 조립까지 된다 -> 조립에 대한 순서를 역순으로 객체를 생성하는 컨테이너(IoC Container)

* 부품이 역순으로 결합되고 담겨진다는 의미 강하게 내포














