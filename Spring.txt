스프링의 시작이다..!!


< ------------------------------------------------------------Spring 소개와 학습 안내------------------------------------------------------------>
* Spring이 존재감을 보이게 된 이유
	1. dependency injection 기능	>> Enterprise Application 만들때 중요함
	2. transaction management 기능	>> 트랜잭션 관리를 깔끔하게 지원해준다. (단순하게 라이브러리만 쓰는방식으로 깔끔하게 처리 및 DI을 같이 쉽게 구현 -> 모듈결합 쉬워짐)

* Java EE버젼을 사용하지 않게됨
	기존 Java SE에 Java EE를 얹어서 사용했지만 이젠 Java SE + Spring으로 엮어서 사용가능하다

* 웹개발을 하겠다에 포커스를 맞추면 3가지 범주에 포커스가 맞춰짐
	
	1. MVC	---> 기존 MVC 모델방식으로 만들면 일일이 만들어야한다는 부담감 증가	---> Spring 라이브러리를 이용해 좀 더 편하게 만들기 가능
	>> Spring 제공하는 기능 ---> DI(Spring에서 MVC를 이용할때 이용됨) ---> 이걸 사용할 때 이애하기위해 느슨한 결합력과 인터페이스의 의미를 알아야함

	2. 트랜잭션	--->	DAO, Service계층을 나눠 프로그램을 만들경우 그들간 함수호출 관계에서 단일 트랜잭션 만들기 어려웠음 ----> 그것을 가능케하기위해 스프링에서 제공하는 트랜잭션 처리방법 공부함
	>> Spring ---> AOP(Spring에서 트랜잭션 처리시 이용됨)

	3. 인증과 권한	---> 웹사이트에서 사용자 인증과 권한
	>>>Spring ---> Spring서 인증과 권한 할 때 Servlet Filter 이용해 개발됨




< ------------------------------------------------------------느슨한 결합력과 인터페이스------------------------------------------------------------>
* 엔터프라이즈 어플리케이션을 만든다고 하면 기본적으로 사용하는 Layer
	UI 		---- 		Service 	  ---- 				DAO 									---- DB
	사용자의 비즈니스 ---- 사용자 요구에 맞는 서비스 담당 ---- 데이터 소스 접근 방법, 구현기술 숨기고 서비스 레이어에서 순수하게 자바를 이용해 데이터를 제공받을 수 있게해주는 DAO

* 서비스에서 기존 이용하던 DAO 객체(B1)가 새로운 객체(B2)로 수정되면 어떻게 수정해야 할까?
	단순 방법 : B1을 B2로 변경하고 Service에서 소스코드를 B1 -> B2로 변경 ---> 소스코드의 변경이 생기므로 결합력이 매우 높음
		소스코드 변경없이 변경하는 방법(결합력을 낮추는 방법)
	
	해결책1 : Service와 DAO를 결합시키는 작업은 UI에서 처리됨 어떻게? -> private B1 b = new B1(); ---> private B2 b = new B2()가 아닌 인터페이스를 이용해 private B b = new B2(); << (B is Interface type)
		 인터페이스를 이용하면 그 인터페이스를 구현하고 있는 객체들을 모두 참조 가능하다.

	해결책2 : 그러면 private B b = new B2()에서 new B2()는 어떻게 변경? ---> 소스코드를 수정 안하는 방식이 필요 ---> 기존 코드를 들어냄(DI)객체 생성과 조립을 위한 외부 설정 (XML, Annotation)혹은 외부파일을 이용함
		자바객체지향 33강 참조해보기

* 결론
	> 기업형 어플리케이션을 만들며 어떻게 유지보수 해야할까? ---> 소스코드변경은 위험부담 증가 따라서 대치하고 추가하는 방법이 필요
	 ---> 그러기 위해서는 설정 파일이 필요하다. ---> 인터페이스를 이용해 객체를 숨길 수 있다. ---> 결합을 낮추는 방법을 스프링이 도와줄 수 있다.










< ------------------------------------------------------------ DI(Dependency Injection) ------------------------------------------------------------>
* Spring 프레임워크의 가장 기본적인 능력
	1. 객체를 생성하고 조립해주는 능력(종속 객체를 생성 조립해주는 도구)
		여기서 사용되는 용어 [DI(Dependency Injection), IoC Container]
		DI : 부품 조립으로 이해하는 것이 편하다

* 부품 조립의 종류
	<Composition has a (일체형)>
	class A {
	  private B b;
	  public A() {
	    b = new B();
	  }
	}
	--> A가 B를 일체형으로 가졌다  --> 이때 B를 A의 부품이라고 말함(Dependency)

	<Association has a [조립형(세팅을해야만 사용가능)]>
	class A {
	  private B b;

	  public void setB(B b) {
	    this.b = b;
	  }
	}

* 스프링을 얘기할 때 DI가 왜 중요할까?
	> 프로그램을 만들 때 일체형 보다는 조립형이 결합력도 낮아지고 쉽게 갈아끼울 수 있기 때문에
	  업데이트 및 교체시 유용하여 기업형에서 선호하고 자주 사용된다.

	> B b = new B(); // 부품역할의 객체 다른말로 Dependency
	  A a = new A();

	  a.setB(b);	// 부품(Dependency)를 꽂는 작업 즉, 주입(Injection) 이라고 말함
	>> 조립형의 장점은 부품을 쉽게 바꿔 끼울 수 있다는 점 하지만, 부품을 조립해야하는 단점이 존재

* 조립하는 두 가지의 방법
	1. Setter Injection : Setter를 이용해 조립하는 방법(위의 코드)
	2. Construction Injection : 생성자를 이용해 조립하는 방법[B b = new B(); A a = new A(b);]

* 조립형은 자신이 원하는 부품을 선택해 성능을 올릴 수 있다. 하지만 조립하는데 불편함이 존재 --> 조립을 해주는 서비스가 필요
	1. DI(조립)을 해주는 역할 ---> Spring 즉 Dependency를 Injection 해주는 역할이다. ---> Spring을 이용하는 기본적인 이유

* DI는 결국 부품을 조립해준다. [종속성(Dependency) 주입]
* 이런 객체를 조립하는데 Container가 필요하다 이것이 IoC Container








< ------------------------------------------------------------ IoC(Inversion of Control) 컨테이너 ------------------------------------------------------------>
* Spring은 코어 능력은 부품을 조립해주는 능력이다. --> 이를위해 사용자들이 주문서를 넣으면 Spring은 주문서(XML, Annotation)대로 부품을 조립한다.(가장 기본은 XML파일)
* 주문서 입력대로 객체를 생성해서 담을 그릇 == Container이다. 하지만 부품 컨테이너(Dependency Container)가 아닌 IoC 컨테이너로 굳이 말함 왜? 다른 특별한 의미 존재

* 일체형(Composition)과 조립형(Association)의 부품 결합 순서는 다르다.
	> 일체형은 제일 상위 객체가 만들어지면 내부에 객체들이 순서대로 만들어진다.
	> 결합형은 부품이 생성되고 결합되는 순서는 제일 마지막 객체들이 만들어지고 결합된다. 따라서 역순의 순서를 가짐

* 이것이 Inversion of Control 즉 역순으로 무엇인가를 구성하는 컨테이너라는 의미 (IoC Container)
	> Dependency가 조립까지 된다 -> 조립에 대한 순서를 역순으로 객체를 생성하는 컨테이너(IoC Container)

* 부품이 역순으로 결합되고 담겨진다는 의미 강하게 내포










< ------------------------------------------------------------ Dependency를 직접 Injection 하기 ------------------------------------------------------------>
* Spring의 도움을 받아 부품을 생성하고 조립 해야함
	> 전에 부품조립을 Spring의 도움 없이 직접 해보기

public class Program {

	public static void main(String[] args) {
		// Exam = Interface
		// HoseokExam = Exam data 구현 객체
		Exam exam = new HoseokExam();
		
		// ExamConsole = Interface type
		// InlineExamConsole = Exam출력시 한줄에 출력
		//ExamConsole console = new InlineExamConsole(exam);
		
		// InlineExamConsole = Exam출력시 격자 형태로 출력
		ExamConsole console = new GridExamConsole(exam);	
		// InlineExamConsole, GridExamConsole들이 exam을 조립함 --> DI
		
		console.print();
	}
	
}

* 위의 코드에서 DI를 할때 소스코드 수정없이 가능할까? 
	> 가능케 하기 위해서 new GridExamConsole(exam);, new InlineExamConsole(exam); 이 부분이 코드로 존재하면 안됨
	> 그리고 외부설정으로 빼야함 --> 설정을 바꾸면서 DI를 바꿔치기 할 수 있다.
	> 객체를 생성하는 부분을 비워두고 누군가가 대신할 수 있도록 설정을 빼고 조립하는 작업 --> Spring이 대신 해줌











< ------------------------------------------------------------ 스프링 DI 설정을 위해 이클립스 플러그인 설치하기 ------------------------------------------------------------>
* 이전시간에는 자바코드로 DI를 직접 결합함 --> 변경시에 설정으로 빼야함 --> 직접 설정을 만들 수 있지만 잘 정리된 프레임워크가 이점이 있다.
* 이젠 Spring을 이용해서 DI를 구현해보자

* 어떤 모양으로 결합히기를 원하면 지시서가 필요하다(결합순서를 담은) --> Spring에게 SW가 이해할 수 있는 구문규칙을 이용해야함 --> XML, Annotation(XML을 이용할 것)

* XML을 사용해서 주문서 작성 시 마음대로 쓰는것이 아니다 --> 스프링이 제시하고 있는 지시서 양식을 따라 지시해야함
* 이클립스 플러그인을 설치해 작업함 --> 이클립스 Market place -> Spring

* 설치이후 new -> other -> Spring Bean Configuration File -> setting.xml 만들면(이름자유) 자동적으로 설정하는 파일(스프링이 제시하고 있는 지시서 양식)이 자동 생성됨

* 기본적인 준비과정 완료됨







< ------------------------------------------------------------ Spring DI 지시서 작성하기(Spring Bean Configuration) ------------------------------------------------------------>
* Spring을 이용한 DI적용하는 방법

public class Program {

	public static void main(String[] args) {
		Exam exam = new HoseokExam();						>>
		
		// InlineExamConsole, GridExamConsole들이 exam을 조립함 --> DI		>>
		//ExamConsole console = new InlineExamConsole(exam);			>>
		ExamConsole console = new GridExamConsole(exam);			>> HoseokExam을 GridExamConsole이 사용함 (HoseokExam이 DI 즉, 부품)
		
		console.setExam(exam); >> 일반적인 결합 형태
		console.print();
	}
}

* 결합 방식은 크게 두가지가 존재한다. setter, 또는 직접 대입
* 위 두가지 방법을 스프링을 통하면 어떻게 하게 될까?

* 두 개의 부품을 생성하고 -> Injection(결합,주입) 한 다음에 -> 콘솔을 이용해 출력
* 일련의 가정
	> Exam 객체가 변경되거나, Console객체가 변경되면 --> 바뀌는 것들을 설정으로 빼준다.
	> 결합관계도 변경되어야함 --> 결합관계도 설정으로 빼준다.

		빼줌 Exam exam = new HoseokExam();
		// InlineExamConsole, GridExamConsole들이 exam을 조립함 --> DI
		//ExamConsole console = new InlineExamConsole(exam);
		빼줌 ExamConsole console = new GridExamConsole();	
		
		빼줌 console.setExam(exam);

* ExamConsole객체가 필요한데 이것을 설정으로 빼서 누군가가 생성해줘야함 -> 어떻게? -> Spring
* 역할을 스프링이 해주고 코드에서는 설정하는 부분을 분리함
* 기존 빼줘야하는 부분들을 지시서로 변경함. (이전에 만든 setting.xml파일)
	> 지시서 이므로 자바코드가 아닌 데이터 기반으로 작성함

* XML파일에서 객체의 생성 및 결합을 표기하는 방법
	> 생성 : <bean>태그를 이용해 생성할 객체를 지정한다.
		ex) <bean id="exam" class="spring.di.entity.HoseokExam"></bean>  생성하려는객체=class, 
		변수명=id 다만 생성하려는 객체는 동명이인이 존재할 수 있으므로 패키지명까지 같이 작성해야한다. 
		만약 같은 형식의 클래스가 존재하지 않으면 굳이 이름을 적지 않아도 된다. 

	> 결합 : console.setExam(exam);은 어떻게 결합해야 할까? (console이 exam을 갖음)
		아래와 같이 bean태그내에 <property> 태그를 이용해서 결합함 (setExam은 exam이란 속성을 세팅하는 것이므로 property이용)
		property내 속성에 값을 대입
			> name= 호출하려는 함수 --> 다만 setter존재시(setExam일경우) set생략, 대문자-> 소문자 변경(EL태그와 동일) name="exam" == setExam() 동일
			> value= 설정할 값의 이름 (값 형식일 경우 이곳에 작성)
			> ref = 설정할 참조형의 이름 (참조형식일 경우 이곳에 작성)
		다만 위와같은 형식을 이용하기 위해서는 console객체는 setter를 필수로 가지고 있어야한다. 또한 value, ref태그를 둘다 사용할 수 없다.
		위와 같은 과정이 Dependency Injection이 되겠다.

		> 결합코드
		<bean id="console" class="spring.di.ui.GridExamConsole">
			<property name="exam" value="" ref="exam"/>
		</bean>

	> 생성 및 결합 최종 코드 :
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
		
		<bean id="exam" class="spring.di.entity.HoseokExam"></bean>
		<bean id="console" class="spring.di.ui.GridExamConsole">
			<property name="exam" value="" ref="exam"/>
		</bean>
	</beans>











< ------------------------------------------------------------ Spring IoC 컨테이너 사용하기(ApplicationContext 이용하기)  ------------------------------------------------------------>
* 지시서를 읽어서 지시대로 객체를 만들고 만들어진 객체를 활용하는 방법
	> 주체를 생성할때 사용되는 구문 ApplicationContext context = new ClassPathXmlApplicationContext("config.xml");
	> ApplicationContext<Interface> : Spring에서 DI(지시서)를 읽어서 객체를 생성하고 조립하는 구체적 객체의 이름(인터페이스타입)
	> ClassPathXmlApplicationContext(XML_FILE) : 실제적으로 인터페이스를 구현하고 있음 --> 여러 종류의 ApplicationContext 존재

* ApplicationContext의 종류(지시서(XML)를 넘길때 지시서의 위치를 어떻게 넘겨주냐에따라 달라진다)
	> ClassPathXmlApplicationContext	: Application의 ROOT로 부터 경로를 지정(보편적으로 사용됨) --> src폴더가 루트
	> FileSystemXmlApplicaitonContext	: 특정 드라이브 어디에 있다 (현재 파일시스템의 경로를 이용해 루트로부터 써나갈때 사용)
	> XmlWebApplicationContext		: 웹에 지시서를 둠 (web의 url을 이용)
	> AnnotationConfigApplicationContext	: 파일이 아닌 Annotation으로 두었으므로 스캔하는 방법으로 사용된다.

* 실제 객체 생성해보기
	>  그 전에 기본 Java 프로젝트를 convert to Maven해주어 pom에 Spring라이브러리를 추가해줘야한다.
	> pom.xml에서 dependencies 검색으로 springframework검색 이후 org.springframework의 spring-context를 추가한다

	> 이후 ApplicationContext context = new ClassPathXmlApplicationContext("spring/di/setting.xml"); 을 추가하면
	  지시서대로 객체를 2개 생성하고 injection까지 완료해 보따리에 담음
	> 보따리 이름 : IoC Container, 여기서 지시서를 읽고 객체화하고 담은 그릇인데 이것의 구체적인 이름이 context가 된다.
	> IoC Contatiner를 사용할때 id값을 이용해서 꺼내쓰거나 class명(타입명)을 이용해 꺼내쓸 수 있다.


		>> 이름 : ExamConsole console = (ExamConsole) context.getBean("console");
			이름을 가지고 IoC Container에서 꺼내쓰기(Casting 작업이 필요하다)

		>> 타입 : ExamConsole console = context.getBean(ExamConsole.class);
			형식변환은 필요없다, 타입명을 문자열로 전달하는것이 아닌 ExamConsole이라는 녀석의 class타입에 맞는 녀석을 달라는 말
			즉 ExamConsole에 참조될 수 있는 객체를 찾아달라는 말(여기서는 인터페이스 형식이므로 인터페이스 형식에 참조될 수 있는것을 찾음)
			좀 더 구체화된 이름을 사용하면 더 구체화이름에 맞는 객체를 찾아옴
			만약 동일인터페이스로 두가지의 객체를 생성하게 되면 애매해지므로 구분할 수 있는 방법 요함

	> 이름보단 타입으로 불러오는 방식이 간편함

* 지시서 작성, 지시서대로 객체화해서 객체를 꺼내옴 (코드의 변경없이 외부설정에 대한 내용의 변화를 가지고도 프로그램을 변경할 수 있다.)
  즉 변화가 있다면 변화되는 부분을 설정(지시서)로 빼내어서 작성한다.








< ------------------------------------------------------------ 값 형식 DI  ------------------------------------------------------------>
* 지시할때 꼭 ref이 아닌 value를 이용해(<property>) 값을 세팅할 수 도있다. (값을 setter를 이용해 Injecttion하기)
	<bean id="exam" class="spring.di.entity.HoseokExam">
		<!-- 값 형식 DI 설정하기 -->
		<property name="kor" value="20"/>
		<property name="eng" value="50"/>
		<!-- 두 번째 방법 태그를 이용할 수 도있다.-->
		<property name="math">
			<value>80</value>
		</property>
		<property name="com">
			<value>50</value>
		</property>
	</bean>

* 위와같이 설정할 수 있다. 다만 getter, setter가 필수적으로 작성되어있어야 한다.
* 따라서 자바로 할 수 있었던 객체 생성, 초기화, 객체 조립 작업은 지시서에서도 할 수 있어야 한다.








< ------------------------------------------------------------ 생성자 DI  ------------------------------------------------------------>
* 생성자를 이용한 값을 설정하는 방법
	<constructor-arg> 태그를 이용한다.
	> 생성자를 생성하면서 값을 초기화 하는 경우에 사용될 수 있다.
	> 사용하기 이전에 개체 클래스에서 생성자를 추가한다
	<bean id="exam" class="spring.di.entity.HoseokExam">
		<!-- 생성자를 이용한 값 설정 fileds를 이용한 생성자에 순서대로 대입됨-->
		<constructor-arg value="10"/>
		<constructor-arg value="20"/>
		<constructor-arg value="30"/>
		<constructor-arg value="40"/>
	</bean>

	> 다만 위와 같은 문제는 순서가 헷갈릴 수 있으므로 착오를 일으킬 수 있다.
	> 따라서 순서를 지정하기 위해 아래와 같이 index 속성을 지정할 수 있다.
		<constructor-arg index="0" value="10"/>
		<constructor-arg index="1" value="20"/>
		<constructor-arg index="3" value="30"/>
		<constructor-arg index="2" value="40"/>

	> 이때 생성자의 형태는 아래와 같으므로 순서도래 10 20 40 30의 값이 kor, eng, math, com에 초기화된다.
	public HoseokExam(int kor, int eng, int math, int com) {
		this.kor = kor;
		this.eng = eng;
		this.math = math;
		this.com = com;
	}

* index말고도 명시적으로 name속성을 이용해 지정할 수 있다.
		<constructor-arg name="kor" value="10"/>
		<constructor-arg name="eng" value="20"/>
		<constructor-arg name="com" value="30"/>
		<constructor-arg name="math" value="40"/>

* 다만 동일한 순서의 생성자면서 자료형이 다른 생성자 호출의 모호한 매개변수가 존재하는 경우 위와같은 방법이 애매하다
	> 이 때 type도 지정할 수 있는 type옵션도 있다.
		<constructor-arg name="kor" type="float" value="10"/>
		<constructor-arg name="eng" type="float" value="20"/>
		<constructor-arg name="com" type="float" value="30"/>
		<constructor-arg name="math" type="float" value="40"/>

* 다만 생성자를 통해 값 호출시 태그가 너무 번잡하면 조금 더 쉽게 사용할 수 있는 옵션이 있다.
	> 설정 파일 처리기를 추가하여
	> 속성을 간단히 설정

	> xml파일 하단 namespaces를 선택한다 여기서 p라는 항목을 체크한다
	> xmlns:p="http://www.springframework.org/schema/p" 추가된다.
	> p라는 namespace가 추가되고 뒤에 주소는 namespace의 풀네임이 된다.

* namespace란?
	> 이름이라는 것을 식별하기 위해 앞에 붙여지는 성과같은 역할이다.
	> 성이 동일해도 이름을 식별하기위해 확장된 이름을 붙인다.

* 따라서 태그를 사용할때 두 개 이상의 처리기가 하나의 태그를 읽힐 수 있거나 혹은 원하는 처리기가 처리하길 원할때 접두사(namespace)를 사용한다.
	> <홍길동:bean></홍길동:bean>
	> <김길동:bean></김길동:bean>

* 접두사(namespace)를 이용한 태그의 구분이 갖는 두가지 의미
	1. 태그가 특정한 처리기에 의해 실행될 수 있도록 처리기가 처리할 태그를 특정짓기 위함
	2. 태그의 이름을 식별하기 위해 사용됨

* <bean id="exam" class="spring.di.entity.HoseokExam" p:kor="10" p:eng="20" p:math="30" p:com="40"/>
	> 위의 p가 누구에 의해 처리되는지 앞에다 밝혔으므로
	> bean이 가진 속성으로 인식되는것이 아닌 xmlns:p="http://www.springframework.org/schema/p" 처리기가 담당할 속성이라 말해줌

* 특별한 일이 아닌 이상 namespace : p 를 이용하기에 괜찮아 보인다.










< ------------------------------------------------------------ 콜렉션 생성과 DI ------------------------------------------------------------>
* XML을 이용해 콜렉션 생성 및 콜렉션에 객체 참조시키는 초기화 작업을 어떻게 DI 하는지 방법을 알아보자
* 변경하려는 코드
		List<Exam> exams = new ArrayList<>();
		exams.add(new HoseokExam(1,1,1,1));
		
		for (Exam e : exams) {
			System.out.println(e);
		}

* 먼저 bean 태그로 ArrayList생성
	<bean id="exams" class="java.util.ArrayList"/>

* 이후 클래스에서 getBean을 이용해 찾아옴
	List<Exam> exams = (List<Exam>) context.getBean("exams");//new ArrayList<>();

* 그렇다면 exams.add(newHoseokExam(1,1,1,1)); 은 어떻게 변경할까? (exams.add는 setter, getter가 아니므로 property태그를 이용해 세팅하는 방식으로 쓸 수 없음)
	> ArrayList를 생성할때 생성자에 컬렉션을 대입할 수 있는 능력이 있다. (new ArrayList(Collection C)를 이용)
	<bean id="exams" class="java.util.ArrayList">
		<!-- new ArrayList(Collection C)를 이용 -->
		<constructor-arg>
			<list>
				<bean class="spring.di.entity.HoseokExam" p:kor="10" p:eng="20" p:math="30" p:com="40"/>
				<ref bean="exam" />
			</list>
		</constructor-arg>
	</bean>

	> 생성자의 값을 설정하지만 내부에 설정되는 값이 컬렉션이므로 list태그를 이용해 초기화 하고자 하는 내용을 추가한다.
	> 우린 객체를 직접만들어 초기화 한다 이곳에선 굳이 bean의 id값이 필요없다.
	> bean을 직접 만들지 않고 위에 존재하는 객체가 있으면 참조하여 사용할 수 있다. -> ref태그를 이용하여
	> 그렇게 되면 총 2개의 항목이 추가된다 1. 직접 만든 객체, 2.먼저 생성된 객체 참조

	> 이렇게 컬렉션 리스트를 생성자에 넘기는 방식으로 ArrayList를 만들게되면 항목을 추가하지 않아도 for each문에서 반복되어 출력된다.


* 위와 같은 방법은 정적인 방식으로 초기화하고 가져다 쓰는 방법이다.

* 그런데 생성자에다 목록으로 추가된 컬렉션을 가진 ArrayList를 만드는것이 아닌 위 자체가 ArrayList에 전달된 컬렉션이니 컬렉션을 개별적으로 따로 만드는 방법은 없을까?
	> 생성자에다가 목록을 추가하는 방식은 불편

* 그러려면 별도의 namespace가 필요하다 >> util
	기존 list태그는 목록을 세팅할 떄 사용되는 태그로 그 자체가 객체를 만드는 역할을 하진 못함
	util:list는 이름은 같지만 처리기가 다르고 실제로 객체를 만들 수 있도록 하는 능력을 가지고 있다.

* util:list 구현
	<util:list id="exams" list-class="java.util.ArrayList">
		<bean id="exam" class="spring.di.entity.HoseokExam" p:kor="1"
			p:eng="1" p:math="1" p:com="1" />
		<ref bean="exam" />
	</util:list>

	> 다양한 종류의 컬렉션이 존재하므로 어떤 리스트를 사용할지 구체화 해야함 : list-class 옵션
	> 직접 가져다 사용할 수 있으므로 id값 즉 이름을 가져다 사용할 수 있다. : id 옵션





























